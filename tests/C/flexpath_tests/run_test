#!/bin/bash

reader_prog=""
writer_prog=""
qflag=no;
transport="flx"
timeout="60"
nr="2"
nw="2"
debugger="gdb"
verbose_reader='1>/dev/null'
verbose_writer='1>/dev/null'
no_timeout=0;

# 3 is the file descriptor for the reader 
exec 3<> /dev/null

# 4 is the file descriptor for the writer 
exec 4<> /dev/null

gdb -v >/dev/null 2>&1 || { echo "status was $?"; debugger="lldb"; }
$debugger -v >/dev/null 2>&1 || { debugger="not found"; }

usage() 
{ 
  cat << EO 
        Usage: $PROGNAME [options] 
               $PROGNAME -o <version> -c 

	Run a test under flexpath_tests.
        

        Options: 
EO
  cat <<EO | column -s\& -t 
        -h|--help & show this output 
	-r <name> & name of reader-side program (required)
	-w <name> & name of writer-side program (required)
	-n <count> & number of nodes to run both sides
	-nw <count> & number of nodes to run write side
	-nr <count> & number of nodes to run read side
	-q & be quiet
        -f & turn on flexpath_verbose
        -m & turn off the timeout
        -v & be verbose
        -vr & verbose reader
        -vw & verbose writer
	-timeout <seconds> & timeout in seconds
	-t <transport> & ADIOS transport to use "flx" or ?
EO
} 

PROGNAME=${0##*/} 
SHORTOPTS="r:w:n:t:o:qhvfm" 
LONGOPTS="nw:,nr:,vr,vw,help,timeout:,debug_reader,debug_writer,valgrind_reader,valgrind_writer" 

ARGS=$(getopt -a -s bash --options $SHORTOPTS  \
  --longoptions $LONGOPTS --name $PROGNAME -- "$@" ) 

eval set -- "$ARGS" 

while [ $# -gt 0 ]
do
    case "$1" in
     -h|--help) 
         usage 
         exit 0 
         ;; 
    (-q) qflag=yes;;
    (-r) reader_prog="$2"; shift;;
    (-w) writer_prog="$2"; shift;;
    (-n) nw="$2"; nr="$2"; shift;;
    (-f) export FLEXPATH_VERBOSE=1;;
    (-v) exec 3>&1; exec 4>&1;;
    (-m) no_timeout=1;;
    (--vr) exec 3>&1;;
    (--vw) exec 4>&1;;
    (--nw) nw="$2"; shift;;
    (--nr) nr="$2"; shift;;
    (-t) transport="$2"; shift;;
    (--timeout) timeout="$2"; shift;;
    (--debug_reader)  reader_mode="debug";timeout="600";;
    (--debug_writer)  writer_mode="debug";timeout="600";;
    (--valgrind_reader)  reader_mode="valgrind";;
    (--valgrind_writer)  writer_mode="valgrind";;
    (--) shift; break;;
    (-*) echo "$0: error - unrecognized option $1" 1>&2; exit 1;;
    (*)  break;;
    esac
    shift
done

if [ -z $reader_prog ] || [ -z $writer_prog ]
then
    usage
    exit 1
fi

# remove any lingering flexpath startup files
rm -f *writer_info.txt *writer_ready.txt *reader_info.txt *reader_ready.txt

# Spawn the writer
if [ "$writer_mode" = "debug" ]; then
    if [ "$debugger" = "lldb" ]; then
	echo "	(mpirun -n $wr xterm -e lldb ./$writer_prog -- -t $transport 1>&4 2>&1) & writer_pid=$!"
	(mpirun -n $nw xterm -e lldb ./$writer_prog -- -t $transport 1>&4 2>&1) & writer_pid=$!
    elif [ "$debugger" = "gdb" ]; then
	echo "(mpirun -n $nw xterm -e gdb -args ./$writer_prog -t $transport 1>&4 2>&1) & writer_pid=$!"
	(mpirun -n $wr xterm -e gdb -args ./$writer_prog -t $transport 1>&4 2>&1) & writer_pid=$!
    else 
	echo "Unknown debugger \"$debugger\"";
    fi
elif [ "$writer_mode" = "valgrind" ]; then 
    echo "Doing     (mpirun -n $nw xterm -hold -e valgrind --tool=memcheck ./$writer_prog -t $transport ) & writer_pid=$!"
    (mpirun -n $nw xterm -hold -sl 10000 -e valgrind --tool=memcheck ./$writer_prog -t $transport ) & writer_pid=$!
else
    echo "Doing        (mpirun -n $nw ./$writer_prog -t $transport 1>&4 2>&1) & writer_pid=$!"
    (mpirun -n $nw ./$writer_prog -t $transport 1>&4 2>&1 ) & writer_pid=$!
fi


#sleep 2

# Spawn the reader
if [ "$reader_mode" = "debug" ]; then
    if [ "$debugger" = "lldb" ]; then
	(mpirun -n $nr xterm -e lldb ./$reader_prog -- -t $transport 1>&3 2>&1) & reader_pid=$!
    elif [ "$debugger" = "gdb" ]; then
	(mpirun -n $nr xterm -e gdb -args ./$reader_prog -t $transport 1>&3 2>&1) & reader_pid=$!
    else 
	echo "Unknown debugger \"$debugger\"";
    fi
elif [ "$reader_mode" = "valgrind" ]; then 
    (mpirun -n $nr xterm -hold -sl 10000 -e valgrind --tool=memcheck ./$reader_prog -t $transport ) & reader_pid=$!
else
    (mpirun -n $nr ./$reader_prog -t $transport 1>&3 2>&1) & reader_pid=$!
fi

# in the background, sleep for timeout secs then kill that processes
if [ $no_timeout -eq 0 ]
then
    echo "Sleeping for $timeout"
    (sleep $timeout && kill -9 $reader_pid && kill -9 $writer_pid 2>/dev/null) & waiter=$!
else
    echo "No timeout...moving on."
fi

# wait on our worker process and return the exitcode
wait $reader_pid
reader_exitcode=$?

# wait on our worker process and return the exitcode
wait $writer_pid
writer_exitcode=$?

# kill the waiter subshell, if it still runs
finished_gracefully=0
if [ $no_timeout -eq 0 ]
then
    kill -9 $waiter 2>/dev/null
    # 0 if we killed the waiter, cause that means the process finished before the waiter
    finished_gracefully=$?
    # wait for waiter so that we don't get a killed message
    wait $waiter 2>/dev/null
fi


exit_value=0
if [ "$writer_exitcode" -ne "0" ]; then
  echo "$writer_prog exited with error code $writer_exitcode"
  exit_value=1
fi
if [ "$reader_exitcode" -ne "0" ]; then
  echo "$reader_prog exited with error code $reader_exitcode"
  exit_value=1
fi
if [ "$finished_gracefully" -ne "0" ]; then
  echo "One or more processes had to be killed because of timeout"
  exit_value=1
fi

if [ $qflag != "yes" ]; then
  if [ $exit_value -eq "0" ]; then
     echo "TEST PASSED";
  else
     echo "TEST FAILED";
  fi
fi

exit $exit_value
